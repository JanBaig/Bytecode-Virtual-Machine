# Solution to Challenges 

### Challenge #1
```
What bytecode instruction sequences would you generate for the following expressions:

a. 1 * 2 + 3
b. 1 + 2 * 3
c. 3 - 2 - 1
d. 1 + 2 * 3 - 4 / -5

(Remember that Lox does not have a syntax for negative number literals, so the -5 is negating the number 5.)
```
### Solution #1 

a. `1 * 2 + 3`
```c++
CONST 1
CONST 2
MULTIPLY
CONST 3
ADD
```
b. `1 + 2 * 3` 
```c++
CONST 1
CONST 2
CONST 3
MULTIPLY
ADD
``` 
c. `3 - 2 - 1`
```c++
CONST 3
CONST 2
SUBTRACT
CONST 1
SUBTRACT
``` 
d. `1 + 2 * 3 - 4 / -5`

```c++
CONST 1
CONST 2
CONST 3
MULTIPLY
ADD
CONST 4
CONST 5
NEGATE
DIVIDE
SUBTRACT
``` 
### Challenge #2
```
If we really wanted a minimal instruction set, we could eliminate either OP_NEGATE or OP_SUBTRACT. 
Show the bytecode instruction sequence you would generate for: 

4 - 3 * -2

First, without using OP_NEGATE. Then, without using OP_SUBTRACT.
Given the above, do you think it makes sense to have both instructions? Why or why not? 
Are there any other redundant instructions you would consider including?
```
### Solution #2 

Without `OP_NEGATE`
```c++
CONST 4
CONST 3
CONST 0 
CONST 2
SUBTRACT // 0 -2 would push -2 onto the stack  
MULTIPLY
SUBTRACT
```
Wihtout `OP_SUBTRACT` 
```c++
CONST 4 
CONST 3 
CONST 2 
NEGATE 
MULTIPLY 
NEGATE // very similar to how subtraction is done on a lower level
ADD
``` 

### Challenge #3 
```
Our VM’s stack has a fixed size, and we don’t check if pushing a value overflows it. 
This means the wrong series of instructions could cause our interpreter to crash or go into
undefined behavior. Avoid that by dynamically growing the stack as needed.
What are the costs and benefits of doing so?
```

### Solution #3
The solution is similar to the `lines` and `code` dynamic arrays created for a chunk. 
All changes done to complete this challenge can be found [here](https://github.com/JanatB/Bytecode-Virtual-Machine/commit/1328d354a6d45e8a60d66e20786a2b4d041fff25)

<!-- 
### Challenge #4 

```
To interpret OP_NEGATE, we pop the operand, negate the value, and then push the result. 
That’s a simple implementation, but it increments and decrements stackTop unnecessarily, since the 
stack ends up the same height in the end. It might be faster to simply negate the value in place 
on the stack and leave stackTop alone. Try that and see if you can measure a performance
difference. Are there other instructions where you can do a similar optimization?
```
 
### Solution #4 -->


